# Теория

### Базовые концепции
1. В чем разница между конкурентностью и параллелизмом? Назовите основные реализации того и другого в Python.
2. В чем отличие CPU и IO задач?
3. Какие из представленных в Python форм параллелизма/конкурентности используется для решения CPU задач, а какие - для решения IO задач?

### Многопроцессность (Мультипроцессинг) 
1. Что такое процесс?
2. Что такое многопроцессность? Какая библиотека в Python отвечает за работу с многопроцессностью?
3. Как разные процессы обмениваются данными?
4. Что такое `multiprocessing.Pool`? Зачем он нужен?
5. Сколько процессов может выполняться одновременно? От чего это зависит?

### Многопоточность 
1. Что такое поток? В чем отличие от процесса?
2. Что такое многопоточность? В чем отличия от многопроцессности?
3. Что такое GIL? Как он влияет на потоки и процессы?
4. Зачем был создан GIL, и почему его до сих пор не упразднили?
5. Опишите, как работают два потока, запущенные в одной программе.
6. В чем заключается небезопасность многопоточности?
7. Синхронизация и ограничения потоков/процессов. Что такое `Lock`, `Semaphore`, `Event`, `Barrier`?
8. Что такое deadlock и livelock?
9. Что такое `ThreadPoolExecutor`? Зачем он нужен?

### Асинхронность
1. Что такое асинхронный код?
2. Зачем нужна асинхронность, если есть многопоточность? В чем преимущества?
3. Как происходит смещение фокуса выполнения программы при асинхронности и многопоточности?
4. В каких случаях может потребоваться использование многопоточности, а не асинхронности?
5. Что такое блокирующая задача? Как запустить ее в асинхронном коде?
6. Что такое корутина? Как ее создать?
7. Что такое цикл событий? Как он устроен?
8. Как вручную запустить цикл событий? Как добавить задачу в уже запущенный цикл событий?
9. Что такое `Future` и `Task`?
10. Зачем нужен `asyncio.create_task()`?
11. Чем отличается `asyncio.gather()` от `asyncio.wait()`?
12. Как добавить таймаут на выполнение асинхронной функции? Как отменить задачу?
13. Как создать и использовать асинхронный контекстный менеджер?

# Практика

1. Самостоятельно напишите следующие функции для практики алгоритмов: **Поиск N-го числа Фибоначчи**, **Поиск N-го простого числа** и **Поиск факториала**.
Запустите данные функции последовательно в одном процессе, а потом - каждую в отдельном процессе. С помощью библиотеки `time` замерьте и сравните время выполнения последовательного и параллельного выполнения программы.
2. Создайте класс `BankAccount` с полем `balance`, реализуйте методы `deposit(amount: float)` (пополнение) и `withdraw(amount: float)` (списание).
Запустите несколько потоков, которые одновременно меняют баланс и добейтесь возникновения `RaceCondition`. Скопируйте код, в копии избавьтесь от `RaceCondition` одним из методов ограничения потоков.
3. Реализуйте асинхронный код, который отправляет 50 запросов по адресу http://google.com/ или https://example.com/. Ограничьте одновременное количество возможных запросов до 10.
Статус-коды ответов запишите в файл. Количество запросов `requests_amount`, лимит одновременно выполняемых запросов `requests_limit` и `url` должны передаваться как входные аргументы функции.
